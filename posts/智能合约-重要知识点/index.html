<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>智能合约 - 重要知识点 | Viper</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="智能合约 - 知识点 🔗学习课程：https://cryptozombies.io/ 字符串 🔗String：字符串用于保存任意长度的 UTF-8 编码数据。 数组">
<meta name="generator" content="Hugo 0.101.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-3CPL7G0HYV', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	<a href="/posts">归档</a>
	<a href="/tags">标签</a>
	<a href="/about">关于</a>

	

	
	  <a class="button" href="https://viper00.fun/index.xml">订阅</a>
	
</nav>


    <main class="main">
      

<section id="single">
    <h1 class="title">智能合约 - 重要知识点</h1>

    <div class="tip">
        <time datetime="2022-09-05 12:59:31 &#43;0800 CST">2022年09月05日</time>
        <span class="split">
          ·
        </span>
        <span>
          3465字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          7分钟
        </span>
    </div>

    
    
        
  
    <aside class="toc">
      <details>
          <summary>Table of Contents
          </summary>
          <div>
              <nav id="TableOfContents">
  <ul>
    <li><a href="#字符串">字符串</a></li>
    <li><a href="#数组">数组</a></li>
    <li><a href="#私有公共函数">私有/公共函数</a></li>
    <li><a href="#事件">事件</a></li>
    <li><a href="#函数修饰符">函数修饰符</a>
      <ul>
        <li><a href="#可见性修饰符">可见性修饰符</a></li>
        <li><a href="#状态修饰符">状态修饰符</a></li>
        <li><a href="#自定义-modifiers">自定义 Modifiers</a></li>
      </ul>
    </li>
    <li><a href="#payable">Payable</a></li>
    <li><a href="#随机数">随机数</a></li>
    <li><a href="#代币">代币</a>
      <ul>
        <li><a href="#erc20-代币">ERC20 代币</a></li>
        <li><a href="#erc721-代币">ERC721 代币</a></li>
      </ul>
    </li>
    <li><a href="#合约安全措施">合约安全措施</a></li>
    <li><a href="#safemath">SafeMath</a></li>
    <li><a href="#assert-和-require-的区别">Assert 和 Require 的区别</a></li>
    <li><a href="#注释">注释</a></li>
    <li><a href="#合约">合约</a></li>
    <li><a href="#wei">Wei</a></li>
    <li><a href="#web3js">Web3.js</a></li>
    <li><a href="#web3-提供者web3-provider">Web3 提供者(Web3 Provider)</a>
      <ul>
        <li><a href="#infura">Infura</a></li>
        <li><a href="#metamask">Metamask</a></li>
      </ul>
    </li>
    <li><a href="#indexed">Indexed</a></li>
    <li><a href="#addresses地址">Addresses（地址）</a></li>
    <li><a href="#mapping映射">Mapping（映射）</a></li>
    <li><a href="#msgsender">msg.sender</a></li>
    <li><a href="#require">Require</a></li>
    <li><a href="#继承inheritance">继承（Inheritance）</a></li>
    <li><a href="#引入import">引入（Import）</a></li>
    <li><a href="#存储变量storagememory">存储变量（storage、memory）</a></li>
    <li><a href="#智能合约的永固性">智能合约的永固性</a></li>
    <li><a href="#openzeppelin-库的-ownable-合约">OpenZeppelin 库的 Ownable 合约</a></li>
    <li><a href="#gas">Gas</a></li>
    <li><a href="#summary">Summary</a></li>
  </ul>
</nav>
          </div>
      </details>
    </aside>
  


    


    <div class="content">
      <h1 id="智能合约---知识点">智能合约 - 知识点 <a href="#%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6---%e7%9f%a5%e8%af%86%e7%82%b9" class="anchor">🔗</a></h1><p>学习课程：https://cryptozombies.io/</p>
<h2 id="字符串">字符串 <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2" class="anchor">🔗</a></h2><p>String：字符串用于保存任意长度的 UTF-8 编码数据。</p>
<h2 id="数组">数组 <a href="#%e6%95%b0%e7%bb%84" class="anchor">🔗</a></h2><p>Public 数组, Solidity 会自动创建 getter 方法。</p>
<h2 id="私有公共函数">私有/公共函数 <a href="#%e7%a7%81%e6%9c%89%e5%85%ac%e5%85%b1%e5%87%bd%e6%95%b0" class="anchor">🔗</a></h2><ul>
<li><strong>Public</strong></li>
<li><strong>_Private</strong></li>
</ul>
<h2 id="事件">事件 <a href="#%e4%ba%8b%e4%bb%b6" class="anchor">🔗</a></h2><p>事件是合约和区块链通讯的一种机制。前端应用监听某些事件，并做出反应。</p>
<h2 id="函数修饰符">函数修饰符 <a href="#%e5%87%bd%e6%95%b0%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="anchor">🔗</a></h2><h3 id="可见性修饰符">可见性修饰符 <a href="#%e5%8f%af%e8%a7%81%e6%80%a7%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="anchor">🔗</a></h3><ul>
<li><strong>Private</strong>：合约内部调用。</li>
<li><strong>Internal</strong>：合约内部调用，能被继承的合约调用。</li>
<li><strong>External</strong>：外部合约调用。</li>
<li><strong>Public</strong>：任何地方调用，无论外部还是内部。</li>
</ul>
<h3 id="状态修饰符">状态修饰符 <a href="#%e7%8a%b6%e6%80%81%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="anchor">🔗</a></h3><ul>
<li><strong>View</strong>：运行这个函数不会更改和保存任何数据。</li>
<li><strong>Pure</strong>：运行这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。</li>
</ul>
<p>注意：这两种在被外部合约调用时候不花费任何 gas，但从内部其他函数调用时会耗费 gas。</p>
<h3 id="自定义-modifiers">自定义 Modifiers <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89-modifiers" class="anchor">🔗</a></h3><p>如 onlyOwner、aboveLevel：自定义对函数的约束逻辑。</p>
<h2 id="payable">Payable <a href="#payable" class="anchor">🔗</a></h2><p>Payable：接收以太的特殊函数。</p>
<p>在以太坊中， 因为钱（以太）和数据（事务负载），以及合约代码本身都存在于以太坊。Payable 可以同时调用函数并付钱给另外一个合约。</p>
<p>例如向一个合约要求支付一定的钱来运行一个函数。</p>
<p>注意：如果一个函数没标记为 <strong>payable</strong>， 而你尝试发送以太，函数将拒绝你的事务。</p>
<ul>
<li><strong>this.balance</strong> 将返回当前合约存储了多少以太。</li>
<li><strong>transfer</strong> 向任何以太坊地址付钱。</li>
</ul>
<h2 id="随机数">随机数 <a href="#%e9%9a%8f%e6%9c%ba%e6%95%b0" class="anchor">🔗</a></h2><p>用 <strong>keccak256</strong> 来制造随机数，随机数生成器是 keccak256 哈希函数。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#080;font-style:italic">// 生成一个 0 到 100 的随机数:
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>uint randNonce <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>uint random <span style="color:#666">=</span> uint(keccak256(now, msg.sender, randNonce)) <span style="color:#666">%</span> <span style="color:#666">100</span>;
</span></span><span style="display:flex;"><span>randNonce<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>uint random2 <span style="color:#666">=</span> uint(keccak256(now, msg.sender, randNonce)) <span style="color:#666">%</span> <span style="color:#666">100</span>;
</span></span></code></pre></div><h2 id="代币">代币 <a href="#%e4%bb%a3%e5%b8%81" class="anchor">🔗</a></h2><p>一个代币在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 transfer(address _to, uint256 _value) 函数和 balanceOf(address _owner) 函数.</p>
<h3 id="erc20-代币">ERC20 代币 <a href="#erc20-%e4%bb%a3%e5%b8%81" class="anchor">🔗</a></h3><p>由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。</p>
<h3 id="erc721-代币">ERC721 代币 <a href="#erc721-%e4%bb%a3%e5%b8%81" class="anchor">🔗</a></h3><p>ERC721 代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。</p>
<p>使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑。</p>
<h2 id="合约安全措施">合约安全措施 <a href="#%e5%90%88%e7%ba%a6%e5%ae%89%e5%85%a8%e6%8e%aa%e6%96%bd" class="anchor">🔗</a></h2><p>溢出（overflow）：假设我们有一个 uint8, 只能存储 8bit 数据。这意味着我们能存储的最大数字就是二进制 11111111 (也就是十进制的 2^8 - 1 = 255)。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>uint8 number <span style="color:#666">=</span> <span style="color:#666">255</span>;
</span></span><span style="display:flex;"><span>number<span style="color:#666">++</span>; <span style="color:#080;font-style:italic">// 出现溢出错误
</span></span></span></code></pre></div><p>下溢（underflow）：如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>uint8 number <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>number<span style="color:#666">--</span>; <span style="color:#080;font-style:italic">// 出现下溢错误
</span></span></span></code></pre></div><h2 id="safemath">SafeMath <a href="#safemath" class="anchor">🔗</a></h2><p>OpenZeppelin 建立了一个叫做 SafeMath 的库（library），主要有四个方法：add、sub、mul、div。</p>
<h2 id="assert-和-require-的区别">Assert 和 Require 的区别 <a href="#assert-%e5%92%8c-require-%e7%9a%84%e5%8c%ba%e5%88%ab" class="anchor">🔗</a></h2><p>Assert 和 Require 区别在于，Require 若失败则会返还给用户剩下的 gas，Assert 则不会。所以大部分情况下，你写代码的时候会比较喜欢 Require，Assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。</p>
<h2 id="注释">注释 <a href="#%e6%b3%a8%e9%87%8a" class="anchor">🔗</a></h2><p>natspec 格式</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>@title（标题）
</span></span><span style="display:flex;"><span>@author（作者）
</span></span><span style="display:flex;"><span>@notice（须知）向用户解释这个方法或者合约是做什么的
</span></span><span style="display:flex;"><span>@dev（开发者）是向开发者解释更多的细节
</span></span><span style="display:flex;"><span>@param（参数）
</span></span><span style="display:flex;"><span>@return（返回） 用来描述这个方法需要传入什么参数以及返回什么值。
</span></span></code></pre></div><h2 id="合约">合约 <a href="#%e5%90%88%e7%ba%a6" class="anchor">🔗</a></h2><p>Web3.js 需要两个东西来和合约对话：地址和 ABI。</p>
<ul>
<li>合约地址：部署合约区块链上的地址。</li>
<li>合约 ABI：ABI 意为应用二进制接口（Application Binary Interface）。 基本上，它是以 JSON 格式表示合约的方法，告诉 Web3.js 如何以合同理解的方式格式化函数调用。</li>
</ul>
<p>以太坊节点只能识别一种叫做 <strong>JSON-RPC</strong> 的语言：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#008000;font-weight:bold">&#34;jsonrpc&#34;</span>:<span style="color:#b44">&#34;2.0&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;method&#34;</span>:<span style="color:#b44">&#34;eth_sendTransaction&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;params&#34;</span>:[{<span style="color:#008000;font-weight:bold">&#34;from&#34;</span>:<span style="color:#b44">&#34;0xb60e8dd61c5d32be8058bb8eb970870f07233155&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;to&#34;</span>:<span style="color:#b44">&#34;0xd46e8dd67c5d32be8058bb8eb970870f07244567&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;gas&#34;</span>:<span style="color:#b44">&#34;0x76c0&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;gasPrice&#34;</span>:<span style="color:#b44">&#34;0x9184e72a000&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;value&#34;</span>:<span style="color:#b44">&#34;0x9184e72a&#34;</span>,<span style="color:#008000;font-weight:bold">&#34;data&#34;</span>:<span style="color:#b44">&#34;0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675&#34;</span>}],<span style="color:#008000;font-weight:bold">&#34;id&#34;</span>:<span style="color:#666">1</span>}
</span></span></code></pre></div><h2 id="wei">Wei <a href="#wei" class="anchor">🔗</a></h2><p>一个 Wei 是以太的最小单位，1 ether 等于 10^18 Wei。</p>
<h2 id="web3js">Web3.js <a href="#web3js" class="anchor">🔗</a></h2><p>Ethereum JavaScript API：https://github.com/ChainSafe/web3.js</p>
<h2 id="web3-提供者web3-provider">Web3 提供者(Web3 Provider) <a href="#web3-%e6%8f%90%e4%be%9b%e8%80%85web3-provider" class="anchor">🔗</a></h2><p>在 Web3.js 里设置 Web3 的 Provider（提供者）告诉代码应该和哪个节点交互来处理读写。</p>
<h3 id="infura">Infura <a href="#infura" class="anchor">🔗</a></h3><p><a href="https://infura.io/" target="_blank" rel="noopener">Infura</a>  是一个服务，它维护了很多以太坊节点并提供了一个缓存层来实现高速读取。可以用他们的 API 来免费访问这个服务。 用 Infura 作为节点提供者，你可以不用自己运营节点就能很可靠地向以太坊发送、接收信息。</p>
<blockquote>
<p>注意: 以太坊 (以及通常意义上的 blockchains )使用一个公钥/私钥对来对给事务做数字签名。把它想成一个数字签名的异常安全的密码。这样当我修改区块链上的数据的时候，我可以用我的公钥来证明我就是签名的那个。但是因为没人知道私钥，所以没人能伪造事务。</p>
</blockquote>
<h3 id="metamask">Metamask <a href="#metamask" class="anchor">🔗</a></h3><p><a href="https://metamask.io/" target="_blank" rel="noopener">Metamask</a>  是 Chrome 和 Firefox 的浏览器扩展，它能让用户安全地维护自己的以太坊账户和私钥， 并用他们的账户和支持 Web3.js 的网站互动。</p>
<p>Web 检查示例脚本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#a2f">window</span>.addEventListener(<span style="color:#b44">&#39;load&#39;</span>, <span style="color:#a2f;font-weight:bold">function</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// 检查web3是否已经注入到(Mist/MetaMask)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#a2f;font-weight:bold">typeof</span> web3 <span style="color:#666">!==</span> <span style="color:#b44">&#39;undefined&#39;</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 使用 Mist/MetaMask 的提供者
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    web3js <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Web3(web3.currentProvider);
</span></span><span style="display:flex;"><span>  } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// 处理用户没安装的情况， 比如显示一个消息
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#080;font-style:italic">// 告诉他们要安装 MetaMask 来使用我们的应用
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#080;font-style:italic">// 现在你可以启动你的应用并自由访问 Web3.js:
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>  startApp()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><h2 id="indexed">Indexed <a href="#indexed" class="anchor">🔗</a></h2><p>为了筛选仅和当前用户相关的事件，Solidity 合约必须使用 indexed 关键字。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">event</span> <span style="color:#00f">Transfer</span>(<span style="color:#0b0;font-weight:bold">address</span> <span style="color:#a2f;font-weight:bold">indexed</span> _from, <span style="color:#0b0;font-weight:bold">address</span> <span style="color:#a2f;font-weight:bold">indexed</span> _to, <span style="color:#0b0;font-weight:bold">uint256</span> _tokenId);
</span></span></code></pre></div><h2 id="addresses地址">Addresses（地址） <a href="#addresses%e5%9c%b0%e5%9d%80" class="anchor">🔗</a></h2><p>特定用户，或智能合约的地址。</p>
<h2 id="mapping映射">Mapping（映射） <a href="#mapping%e6%98%a0%e5%b0%84" class="anchor">🔗</a></h2><p>映射本质上是存储和查找数据所用的键-值对。</p>
<h2 id="msgsender">msg.sender <a href="#msgsender" class="anchor">🔗</a></h2><p>指当前调用者（或智能合约）的 address。</p>
<p>在 Solidity 中，执行函数始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 <strong>msg.sender</strong> 总是存在的。</p>
<p>使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据。</p>
<h2 id="require">Require <a href="#require" class="anchor">🔗</a></h2><p>Require 使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行。</p>
<p>因此，在调用一个函数之前，用 Require 验证前置条件是非常有必要的。</p>
<h2 id="继承inheritance">继承（Inheritance） <a href="#%e7%bb%a7%e6%89%bfinheritance" class="anchor">🔗</a></h2><p>当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。</p>
<h2 id="引入import">引入（Import） <a href="#%e5%bc%95%e5%85%a5import" class="anchor">🔗</a></h2><p>在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句</p>
<h2 id="存储变量storagememory">存储变量（storage、memory） <a href="#%e5%ad%98%e5%82%a8%e5%8f%98%e9%87%8fstoragememory" class="anchor">🔗</a></h2><p><strong>Storage</strong> 变量是指永久存储在区块链中的变量，<strong>Memory</strong> 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。</p>
<p>大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为<strong>存储</strong>形式，并永久写入区块链；而在函数内部声明的变量是<strong>内存</strong>型的，它在函数调用结束后消失。</p>
<p>状态变量是被永久地保存在合约中，也就是说它们被写入以太币区块链中，可以想象成写入一个数据库内。</p>
<h2 id="智能合约的永固性">智能合约的永固性 <a href="#%e6%99%ba%e8%83%bd%e5%90%88%e7%ba%a6%e7%9a%84%e6%b0%b8%e5%9b%ba%e6%80%a7" class="anchor">🔗</a></h2><p>在你把智能协议传上以太坊之后，它就变得<strong>不可更改</strong>, 这种永固性意味着你的代码永远不能被调整或更新。</p>
<p>编译的程序会一直的、永久的、不可更改的，存储在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。</p>
<p>但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。</p>
<h2 id="openzeppelin-库的-ownable-合约">OpenZeppelin 库的 Ownable 合约 <a href="#openzeppelin-%e5%ba%93%e7%9a%84-ownable-%e5%90%88%e7%ba%a6" class="anchor">🔗</a></h2><p>OpenZeppelin 是主打安保和社区审查的智能合约库。</p>
<p>所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心化，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门。</p>
<p>作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。</p>
<h2 id="gas">Gas <a href="#gas" class="anchor">🔗</a></h2><p>在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 <strong>gas</strong> 费，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。</p>
<p>一次操作所需要花费的 <strong>gas</strong> 费等于这个操作背后的所有运算花销的总和。存储数据比做加法运算贵得多。</p>
<p>由于运行你的程序需要花费用户的真金白银，所以在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来说，运行花费更高，因为这显然会给成千上万的用户带来大量不必要的开销。</p>
<p>如果你使用侧链，倒不一定需要付费。比如 Loom Network 上构建的 CryptoZombies 就是免费的。</p>
<p>如果一个 <strong>view</strong> 函数在另一个函数的内部被调用，而调用函数与 <strong>view</strong> 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 <strong>view</strong> 的函数只有在外部调用时才是免费的。</p>
<h2 id="summary">Summary <a href="#summary" class="anchor">🔗</a></h2><p>好好学习，天天向上。</p>
<p>Happy Coding!</p>

    </div>

    
    
    
  <div id="comment">
    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "blog-dxmvw3ac3t" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>


</section>


    </main>
    
    <footer id="footer">
    
        <div id="social">


    <a class="symbol" href="https://github.com/viper-00" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28"  viewBox="0 0 72 72" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    
    <title>Github</title>
    <desc>Created with Sketch.</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)">
            <g id="Github" transform="translate(264.000000, 939.000000)">
                <path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" id="Rounded" fill="#bbbbbb"></path>
                <path d="M35.9985,13 C22.746,13 12,23.7870921 12,37.096644 C12,47.7406712 18.876,56.7718301 28.4145,59.9584121 C29.6145,60.1797862 30.0525,59.4358488 30.0525,58.7973276 C30.0525,58.2250681 30.0315,56.7100863 30.0195,54.6996482 C23.343,56.1558981 21.9345,51.4693938 21.9345,51.4693938 C20.844,48.6864054 19.2705,47.9454799 19.2705,47.9454799 C17.091,46.4500754 19.4355,46.4801943 19.4355,46.4801943 C21.843,46.6503662 23.1105,48.9634994 23.1105,48.9634994 C25.2525,52.6455377 28.728,51.5823398 30.096,50.9649018 C30.3135,49.4077535 30.9345,48.3460615 31.62,47.7436831 C26.2905,47.1352808 20.688,45.0691228 20.688,35.8361671 C20.688,33.2052792 21.6225,31.0547881 23.1585,29.3696344 C22.911,28.7597262 22.0875,26.3110578 23.3925,22.9934585 C23.3925,22.9934585 25.4085,22.3459017 29.9925,25.4632101 C31.908,24.9285993 33.96,24.6620468 36.0015,24.6515052 C38.04,24.6620468 40.0935,24.9285993 42.0105,25.4632101 C46.5915,22.3459017 48.603,22.9934585 48.603,22.9934585 C49.9125,26.3110578 49.089,28.7597262 48.8415,29.3696344 C50.3805,31.0547881 51.309,33.2052792 51.309,35.8361671 C51.309,45.0917119 45.6975,47.1292571 40.3515,47.7256117 C41.2125,48.4695491 41.9805,49.9393525 41.9805,52.1877301 C41.9805,55.4089489 41.9505,58.0067059 41.9505,58.7973276 C41.9505,59.4418726 42.3825,60.1918338 43.6005,59.9554002 C53.13,56.7627944 60,47.7376593 60,37.096644 C60,23.7870921 49.254,13 35.9985,13" fill="#FFFFFF"></path>
            </g>
        </g>
    </g>
</svg>
    </a>

    <a class="symbol" href="https://twitter.com/ZhongMingYang00" rel="me" target="_blank">
        
        <svg fill="#bbbbbb" width="28" height="28" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="438.536px" height="438.536px" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536;"
	 xml:space="preserve">
<g>
	<path d="M414.41,24.123C398.333,8.042,378.963,0,356.315,0H82.228C59.58,0,40.21,8.042,24.126,24.123
		C8.045,40.207,0.003,59.576,0.003,82.225v274.084c0,22.647,8.042,42.018,24.123,58.102c16.084,16.084,35.454,24.126,58.102,24.126
		h274.084c22.648,0,42.018-8.042,58.095-24.126c16.084-16.084,24.126-35.454,24.126-58.102V82.225
		C438.532,59.576,430.49,40.204,414.41,24.123z M335.471,168.735c0.191,1.713,0.288,4.278,0.288,7.71
		c0,15.989-2.334,32.025-6.995,48.104c-4.661,16.087-11.8,31.504-21.416,46.254c-9.606,14.749-21.074,27.791-34.396,39.115
		c-13.325,11.32-29.311,20.365-47.968,27.117c-18.648,6.762-38.637,10.143-59.953,10.143c-33.116,0-63.76-8.952-91.931-26.836
		c4.568,0.568,9.329,0.855,14.275,0.855c27.6,0,52.439-8.565,74.519-25.7c-12.941-0.185-24.506-4.179-34.688-11.991
		c-10.185-7.803-17.273-17.699-21.271-29.691c4.947,0.76,8.658,1.137,11.132,1.137c4.187,0,9.042-0.76,14.56-2.279
		c-13.894-2.669-25.598-9.562-35.115-20.697c-9.519-11.136-14.277-23.84-14.277-38.114v-0.571
		c10.085,4.755,19.602,7.229,28.549,7.422c-17.321-11.613-25.981-28.265-25.981-49.963c0-10.66,2.758-20.747,8.278-30.264
		c15.035,18.464,33.311,33.213,54.816,44.252c21.507,11.038,44.54,17.227,69.092,18.558c-0.95-3.616-1.427-8.186-1.427-13.704
		c0-16.562,5.853-30.692,17.56-42.399c11.703-11.706,25.837-17.561,42.394-17.561c17.515,0,32.079,6.283,43.688,18.846
		c13.134-2.474,25.892-7.33,38.26-14.56c-4.757,14.652-13.613,25.788-26.55,33.402c12.368-1.716,23.88-4.95,34.537-9.708
		C357.458,149.793,347.462,160.166,335.471,168.735z"/>
</g>
</svg>

    </a>


</div>

    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       Viper
    
    </div>

    
      <div class="powerby">
        Powered by <a href='http://www.gohugo.io/'>Hugo</a> Theme By <a href='https://github.com/nodejh/hugo-theme-mini'>nodejh</a>
      </div>
    
</footer>



  </body>
</html>
